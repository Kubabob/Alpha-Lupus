# bot.py

#emojis:
#‚úÖ

regulamin = """
¬ß1.1 Szanuj innych.
¬ß1.2 Je≈õli masz problem NIE b√≥j siƒô zapytaƒá, po to tu jeste≈õmy üòâ.
¬ß1.3 Staraj siƒô pisaƒá na kana≈Çach tematycznych, je≈õli nie wiesz gdzie powinien znale≈∫ƒá siƒô tw√≥j problem napisz na og√≥lnym.
¬ß1.4 Nie ma g≈Çupich pyta≈Ñ.
¬ß1.5 ≈ªaden jƒôzyk programowania nie jest gorszy od innych.
¬ß1.6 Zakaz przeklinania na kana≈Çach tekstowych, je≈ºeli naprawdƒô musisz, to cenzuruj, ale nie nadu≈ºywaj przekle≈Ñstw;
¬ß1.7 Zakaz wykorzystywania, oszukiwania i szanta≈ºowania innych u≈ºytkownik√≥w;
¬ß1.8 Zakaz reklamowania jakichkolwiek serwer√≥w, stron itp. bez zgody administracji.
"""

import os
import discord
from discord.ext import commands, tasks
from dotenv import load_dotenv
import aiohttp
import random as r
from itertools import cycle
import time
import asyncio
import requests
from bs4 import BeautifulSoup
import youtube_dl
import nacl
import ffmpeg
from functools import partial

#openai.api_key = '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'

#ZA≈ÅADOWANIE TOKEN√ìW Z .env
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
GUILD = os.getenv('DISCORD_GUILD')
login_ps = os.getenv('LOGIN_PS')
haslo_ps = os.getenv('HASLO_PS')


#NADANIE BOTOWI INTENT(PRAWA)
intents = discord.Intents.all()


#UTWORZENIE BOTA
bot = commands.Bot(command_prefix='/', intents=intents)
bot.remove_command('help')


#ID GILDII
guild_id = 1046717079249768519


#ID KANA≈Å√ìW
przywitanie_id = 1046717746211209267
regulamin_id = 1046725335422599208
admin_channel_id = 1046725335422599209
ogloszenia_id = 1046725510232809572
admin_bot_id = 1060904715065495552


kolejka_piosenek = []

bot_status = cycle(['/help', 'KNALT', 'Smacznej Kawusi'])
@tasks.loop(seconds=10)
async def change_status():
    await bot.change_presence(activity=discord.Game(next(bot_status)))


@tasks.loop(minutes=5)
async def ps_get_info():
    guild = bot.get_guild(guild_id)

    login_url = 'https://ps.ug.edu.pl/login.web'

    payload = {
        'licznik' : 's',
        'login' : login_ps,
        'pass' : haslo_ps
    }

    response = requests.Session()
    web_html = response.post(login_url, data=payload).text
    parsed_html = BeautifulSoup(web_html, 'html.parser')
    ogloszenia_ilosc = parsed_html.find(id='ilNieprzeczytanychOgloszen').text

    for channel in guild.channels:
        if channel.id == ogloszenia_id:
            if ogloszenia_ilosc != '0' and czy_wyslano == False:
                await channel.send(f'Na portalu studenta czeka na nas {ogloszenia_ilosc} og≈Çosze≈Ñ\n'
                                f'https://ps.ug.edu.pl/login.web')
                czy_wyslano = True
            elif ogloszenia_ilosc != '0':
                czy_wyslano = False
                #print('Brak nowych og≈Çosze≈Ñ')


#ROZPOCZƒòCIE DZIA≈ÅANIA BOTA
@bot.event
async def on_ready():

    guild = bot.get_guild(guild_id)

    roles = []
    for role in guild.roles:
        roles.append(role.name)
    
    print(f'{bot.user.name} zawy≈Ç!')
    print(f'cz≈Çonkowie: {[member.name for member in guild.members]}\nilo≈õƒá cz≈Çonkow: {guild.member_count}')
    print(f'role: {roles}')
    change_status.start()
    ps_get_info.start()

    await bot.tree.sync()

       
#PRZY≈ÅƒÑCZENIE CZ≈ÅONKA
@bot.event
async def on_member_join(member):
    guild = bot.get_guild(guild_id)

    for channel in guild.channels:
        if channel.id == przywitanie_id:
            await channel.send(
                f'Witaj {member.mention} na KN ALT!\n'
                f'Nie zapomnij o zapoznaniu siƒô z zasadami!\n'
                f'Zaznacz ‚úÖ i baw siƒô dobrze!'
                )


#USUNIƒòCIE CZ≈ÅONKA
@bot.event
async def on_member_remove(member):
    guild = bot.get_guild(guild_id)

    for channel in guild.channels:
        if channel.id == przywitanie_id:
            await channel.send(
                f'Bƒôdzie nam Ciƒô brakowa≈Ço {member.mention} :cry:'
                )
            await tasks.asyncio.sleep(5)
            await channel.send(
                f'Anyway'
            )


#NADANIE RANGI CZ≈ÅONEK PRZEZ REGULAMIN
@bot.event
async def on_raw_reaction_add(payload: discord.RawReactionActionEvent):
    rola_czlonek = discord.utils.get(payload.member.guild.roles, name='Cz≈Çonek')

    if payload.channel_id != regulamin_id:
        return

    print(f'{str(payload.emoji)}')
    if str(payload.emoji) == '‚úÖ':
        await payload.member.add_roles(rola_czlonek)


@bot.tree.command(name='help', description='/help [komenda]')
async def help(interaction: discord.Interaction, komenda : str = 'all'):
    if komenda == 'all':
        help_embed = discord.Embed(color=discord.Colour.purple())

        help_embed.set_author(name='/help')
        help_embed.add_field(
            name='/ping',
            value='Grasz w pingla z botem',
            inline=False
            )
        help_embed.add_field(
            name='/dog',
            value='Pokazuje pieska',
            inline=False
            )
        help_embed.add_field(
            name='/cat',
            value='Pokazuje kotka',
            inline=False
        )
        help_embed.add_field(
            name='/echo [co chcesz ≈ºebym powiedzia≈Ç]',
            value='Daj mi co≈õ powiedzieƒá',
            inline=False
        )
        help_embed.add_field(
            name='/rps [papier/kamien/no≈ºyce] lub /rock_paper_scissors lub /pkn',
            value='Papier/Kamien/Nozyce => Kamie≈Ñ, Papier, No≈ºyce z botem',
            inline=False
        )
        help_embed.add_field(
            name='/rock',
            value='Kamie≈Ñ',
            inline=False
        )
        help_embed.add_field(
            name='/paper',
            value='Papier',
            inline=False
        )
        help_embed.add_field(
            name="/scissors",
            value='No≈ºyce',
            inline=False
        )
        help_embed.add_field(
            name='/moneta lub /rm',
            value='Rzut monetƒÖ',
            inline=False
        )
        help_embed.add_field(
            name='/roll lub /r [ilo≈õƒá_kostek] [ilo≈õƒá_≈õcianek]',
            value='Rzut kostkƒÖ',
            inline=False
        )
        await interaction.response.send_message(embed=help_embed, ephemeral=True)
    elif komenda == 'ping':
        await interaction.response.send_message(f'Zagraj w ping ponga z botem', ephemeral=True)
    elif komenda == 'dog':
        await interaction.response.send_message(f'Pokazuje pieska', ephemeral=True)
    elif komenda == 'cat':
        await interaction.response.send_message(f'Pokazuje kotka', ephemeral=True)
    elif komenda == 'echo':
        await interaction.response.send_message(f'/echo [co chcesz ≈ºeby bot napisa≈Ç]', ephemeral=True)
    elif komenda == 'rps':
        await interaction.response.send_message(f'/rps [papier/kamien/no≈ºyce\nZagraj z botem w papier kamie≈Ñ no≈ºyce', ephemeral=True)
    elif komenda == 'rock':
        await interaction.response.send_message(f'Rzucasz kamie≈Ñ', ephemeral=True)
    elif komenda == 'paper':
        await interaction.response.send_message(f'Pokazujesz papier', ephemeral=True)
    elif komenda == 'scissors':
        await interaction.response.send_message(f'Wyjmujesz no≈ºyce', ephemeral=True)
    elif komenda == 'moneta' or komenda == 'rm':
        await interaction.response.send_message(f'Rzut monetƒÖ', ephemeral=True)
    elif komenda == 'roll' or komenda == 'r':
        await interaction.response.send_message(f'/r [ilo≈õƒá_kostek] [ilo≈õƒá_≈õcianek]', ephemeral=True)
    else:
        await interaction.response.send_message(f'Nie znam takiej komendy', ephemeral=True)

#HELP @ADMIN
@bot.tree.command(name='help_admin', description='/help_admin [komenda]')
@commands.has_permissions(manage_channels=True)
async def help_admin(interaction: discord.Interaction, komenda : str = 'all'):
    

    if komenda == 'all':
        help_admin_embed = discord.Embed(color=discord.Colour.purple())

        help_admin_embed.set_author(name='/help_admin')
        help_admin_embed.add_field(
        name='/regulamin_maker',
        value='S≈Çu≈ºy do stworzenia regulaminu'
        )
        await interaction.response.send_message(embed=help_admin_embed, ephemeral=True)
    elif komenda == 'regulamin_maker':
        await interaction.response.send_message(f'S≈Çu≈ºy do stworzenia regulaminu', ephemeral=True)
    else:
        await interaction.response.send_message(f'Nie znam takiej komendy', ephemeral=True)


#TWORZENIE REGULAMINU
@bot.tree.command(name='regulamin_maker', description='S≈Çuzy do stworzenia regulaminu')
@commands.has_permissions(manage_channels=True)
async def regulamin_maker(interaction: discord.Interaction):
    regulamin_message = await interaction.channel.send(regulamin)
    await regulamin_message.add_reaction('‚úÖ')


#ERROR DO TWORZENIA REGULAMINU
@regulamin_maker.error
async def regulamin_maker_error(ctx, error):
    if isinstance(error, commands.MissingPermissions):
        error_text = f'''Nie masz uprawnie≈Ñ do komendy "regulamin_maker"'''
        await ctx.channel.send(error_text)


'''@bot.komenda(pass_context = True)
async def clear(ctx):
    print(f'{ctx.channel_id}')
    await ctx.channel.delete_messages(ctx.channel.messages)
    '''

#GRA W PING PONGA
@bot.tree.command(name='ping', description='zwraca PONG')
async def ping(interaction: discord.Interaction):
    await interaction.response.send_message("pong :ping_pong:")

@bot.tree.command(name='slash', description='test')
async def slash(interaction: discord.Interaction, number: int, string: str):
    await interaction.response.send_message(f'Modify {number=} {string=}', ephemeral=True)


#BOT PISZE TO CO TY
@bot.tree.command(name='echo', description='Zmu≈õ bota do napisania czego≈õ')
async def echo(interaction: discord.Interaction, text: str):
    await interaction.response.send_message(f'{text}')


#BOT WYSWIETLA LOSOWEGO KOTA
@bot.tree.command(name='kot', description='Pokazuje kota')
async def kot(interaction: discord.Interaction):
    async with aiohttp.ClientSession() as session:
        async with session.get('http://aws.random.cat/meow') as r:
            if r.status == 200:
                js = await r.json()
                await interaction.response.send_message(js['file'])


#BOT WYSWIETLA LOSOWEGO PSA
@bot.tree.command(name='pies', description='Pokazuje psa')
async def pies(interaction: discord.Interaction):
    async with aiohttp.ClientSession() as session:
        async with session.get('https://random.dog/woof.json') as r:
            if r.status == 200:
                js = await r.json()
                await interaction.response.send_message(js['url'])

#cute - animal


def rps_random():
    moves = ['KAMIEN', 'PAPIER', 'NOZYCE']
    return r.choice(moves)

def rps_game(player, bot):
    if player == bot:
        return "Tie"
    elif player == 'KAMIEN':
        if bot == 'PAPIER':
            return 'Lose'
        else:
            return 'Win'
    elif player == 'PAPIER':
        if bot == 'NOZYCE':
            return 'Lose'
        else:
            return 'Win'
    elif player == 'NOZYCE':
        if bot == 'KAMIEN':
            return 'Lose'
        else:
            return 'Win'
    else:
        return 'error'

@bot.tree.command(name='kamie≈Ñ', description='Rzucasz kamie≈Ñ')
async def kamie≈Ñ(interaction: discord.Interaction):
    bot=rps_random()
    wynik = rps_game(player='ROCK', bot=bot)
    if wynik == 'Tie':
        await interaction.response.send_message(f'{bot}\nRemis! Spr√≥bujmy jeszcze raz!', ephemeral=True)
    elif wynik == 'Lose':
        await interaction.response.send_message(f'{bot}\nPrzegra≈Çe≈õ, ≈ºyczƒô wiƒôcej szczƒô≈õcia nastƒôpnym razem :wink:', ephemeral=True)
    else:
        await interaction.response.send_message(f'{bot}\nWygra≈Çe≈õ!', ephemeral=True)
        await tasks.asyncio.sleep(1)
        await interaction.channel.send('Tym razem :upside_down:', ephemeral=True)

@bot.tree.command(name='papier', description='Pokazujesz papier')
async def papier(interaction: discord.Interaction):
    bot=rps_random()
    wynik = rps_game(player='PAPIER', bot=bot)
    if wynik == 'Tie':
        await interaction.response.send_message(f'{bot}\nRemis! Spr√≥bujmy jeszcze raz!', ephemeral=True)
    elif wynik == 'Lose':
        await interaction.response.send_message(f'{bot}\nPrzegra≈Çe≈õ, ≈ºyczƒô wiƒôcej szczƒô≈õcia nastƒôpnym razem :wink:', ephemeral=True)
    else:
        await interaction.response.send_message(f'{bot}\nWygra≈Çe≈õ!', ephemeral=True)
        await tasks.asyncio.sleep(1)
        await interaction.channel.send('Tym razem :upside_down:', ephemeral=True)

@bot.tree.command(name='nozyce', description='Wyjmujesz nozyce')
async def nozyce(interaction: discord.Interaction):
    bot=rps_random()
    wynik = rps_game(player='NOZYCE', bot=bot)
    if wynik == 'Tie':
        await interaction.response.send_message(f'{bot}\nRemis! Spr√≥bujmy jeszcze raz!', ephemeral=True)
    elif wynik == 'Lose':
        await interaction.response.send_message(f'{bot}\nPrzegra≈Çe≈õ, ≈ºyczƒô wiƒôcej szczƒô≈õcia nastƒôpnym razem :wink:', ephemeral=True)
    else:
        await interaction.response.send_message(f'{bot}\nWygra≈Çe≈õ!', ephemeral=True)
        await tasks.asyncio.sleep(1)
        await interaction.channel.send('Tym razem :upside_down:', ephemeral=True)

'''@bot.komenda()
async def chat(ctx, *args):
    prompt = ' '.join(args)
    response = openai.Completion.create(
        model='text-davinci-003',
        prompt=prompt,
        max_tokens=1024,
        temperature=0.5
    )
    await ctx.message.channel.send(response.get("text"))'''

@bot.tree.command(name='rps', description='Zagraj w papier kamie≈Ñ nozyce')
async def rps(interaction: discord.Interaction, wybor: str):
    wybor = wybor.lower()
    if wybor == 'kamie≈Ñ':
        wybor = 'kamien'
    elif wybor == 'no≈ºyce':
        wybor = 'nozyce'

    opcje = ['papier', 'kamien', 'nozyce']
    losowanko = r.choice(opcje)

    if wybor == losowanko:
        await interaction.response.send_message(f'{losowanko.upper()}!\nAjaj, remis. Jeszcze raz?', ephemeral=True)
    elif wybor == 'kamien':
        if losowanko == 'papier':
            await interaction.response.send_message(f'{losowanko.upper()}!\nWygra≈Çeeem! Nooob ahhahahahxXDDXDXdxD11!1!!!1', ephemeral=True)
        else:
            await interaction.response.send_message(f'{losowanko.upper()}!\nNieeee...! Pokona≈Çe≈õ mnie :CCCC', ephemeral=True)
    elif wybor == 'papier':
        if losowanko == 'nozyce':
            await interaction.response.send_message(f'{losowanko.upper()}!\nWygra≈Çeeem! Nooob ahhahahahxXDDXDXdxD11!1!!!1', ephemeral=True)
        else:
            await interaction.response.send_message(f'{losowanko.upper()}!\nNieeee...! Pokona≈Çe≈õ mnie :CCCC', ephemeral=True)
    elif wybor == 'nozyce':
        if losowanko == 'kamien':
            await interaction.response.send_message(f'{losowanko.upper()}!\nWygra≈Çeeem! Nooob ahhahahahxXDDXDXdxD11!1!!!1', ephemeral=True)
        else:
            await interaction.response.send_message(f'{losowanko.upper()}!\nNieeee...! Pokona≈Çe≈õ mnie :CCCC', ephemeral=True)
    else:
        await interaction.response.send_message('Umiesz pisaƒá???', ephemeral=True)

@bot.tree.command(name='roll', description='Rzuƒá x kostkami y ≈õciennymi')
async def roll(interaction: discord.Interaction, kostki: int = 1, scianki: int = 6, add: int = 0):
    if scianki > 100:
        if kostki > 200:
            await interaction.response.send_message('Mam tylko 200 ko≈õci!\nA najwiƒôksza kostka to d100', ephemeral=True)
        else:
            await interaction.response.send_message('Najwiƒôksza kostka to d100!', ephemeral=True)
    elif kostki > 200:
        await interaction.response.send_message(f'Mam tylko 200 kostek d{scianki}!', ephemeral=True)
    else:
        rolls = [r.randint(1, scianki) for i in range(kostki)]
        odp = ''
        last_roll = rolls.pop(-1)
        try:
            for i in range(-1, kostki):
                odp += f'{str(rolls[i+1])}, '
        except Exception:
            odp += f'{last_roll}\nSuma wynosi: {sum(rolls) + last_roll + add}'

        rolls.append(last_roll)
    
        await interaction.response.send_message(
            f'{odp}\n'
            f'Najwy≈ºsza warto≈õƒá: {max(rolls)}', ephemeral=True)

@bot.tree.command(name='moneta', description='Rzut monetƒÖ')
async def moneta(interaction: discord.Interaction):
    moneta = r.randint(0, 1)
    if moneta == 0:
        await interaction.response.send_message('ORZE≈Å', ephemeral=True)
    else:
        await interaction.response.send_message('RESZKA', ephemeral=True)



youtube_dl.utils.bug_reports_message = lambda: ''

ytdl_format_options = {
    'format': 'bestaudio/best',
    'restrictfilenames': True,
    'noplaylist': True,
    'nocheckcertificate': True,
    'ignoreerrors': False,
    'logtostderr': False,
    'quiet': True,
    'no_warnings': True,
    'default_search': 'auto',
    'source_address': '0.0.0.0' # bind to ipv4 since ipv6 addresses cause issues sometimes
}

ffmpeg_options = {
    'options': '-vn'
}

ytdl = youtube_dl.YoutubeDL(ytdl_format_options)

class YTDLSource(discord.PCMVolumeTransformer):

    def __init__(self, source, *, data, requester):
        super().__init__(source)
        self.requester = requester

        self.title = data.get('title')
        self.web_url = data.get('webpage_url')

        # YTDL info dicts (data) have other useful information you might want
        # https://github.com/rg3/youtube-dl/blob/master/README.md

    def __getitem__(self, item: str):
        """Allows us to access attributes similar to a dict.
        This is only useful when you are NOT downloading.
        """
        return self.__getattribute__(item)

    @classmethod
    async def create_source(cls, ctx, search: str, *, loop, download=False):
        loop = loop or asyncio.get_event_loop()

        to_run = partial(ytdl.extract_info, url=search, download=download)
        data = await loop.run_in_executor(None, to_run)

        if 'entries' in data:
            # take first item from a playlist
            data = data['entries'][0]

        await ctx.send(f'```ini\n[Added {data["title"]} to the Queue.]\n```', delete_after=15)

        if download:
            source = ytdl.prepare_filename(data)
        else:
            return {'webpage_url': data['webpage_url'], 'requester': ctx.author, 'title': data['title']}

        return cls(discord.FFmpegPCMAudio(source), data=data, requester=ctx.author)

    @classmethod
    async def regather_stream(cls, data, *, loop):
        """Used for preparing a stream, instead of downloading.
        Since Youtube Streaming links expire."""
        loop = loop or asyncio.get_event_loop()
        requester = data['requester']

        to_run = partial(ytdl.extract_info, url=data['webpage_url'], download=False)
        data = await loop.run_in_executor(None, to_run)

        return cls(discord.FFmpegPCMAudio(data['url']), data=data, requester=requester)

    @classmethod
    async def from_url(cls, url, *, loop=None, stream=False):
        loop = loop or asyncio.get_event_loop()
        data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=not stream))
        if 'entries' in data:
            # take first item from a playlist
            data = data['entries'][0]
        filename = data['title'] if stream else ytdl.prepare_filename(data)
        return filename


@bot.tree.command(name='join', description='Do≈ÇƒÖcza bota na kana≈Ç g≈Çosowy')
async def join(interaction: discord.Interaction):
    try:
        if not interaction.user.voice:
            await interaction.response.send_message(f'{interaction.user} nie jest po≈ÇƒÖczony do voice chatu', ephemeral=True)
            return
        else:
            channel = interaction.user.voice.channel
        await channel.connect()
        await interaction.response.send_message(f'Juz jestem', ephemeral=True)
    except:
        await interaction.response.send_message(f'Przeciez tu jestem', ephemeral=True)


@bot.tree.command(name='leave', description='Bot opuszcza kana≈Ç g≈Çosowy')
async def leave(interaction: discord.Interaction):
    voice_client = interaction.guild.voice_client
    if voice_client:
        await voice_client.disconnect()
        await interaction.response.send_message(f'Bƒôdƒô tƒôskiƒá', ephemeral=True)
    else:
        await interaction.response.send_message(f'Bot nie jest na kanale g≈Çosowym', ephemeral=True)


@bot.tree.command(name='play', description='Zagraj piosenkƒô')
async def play(interaction: discord.Interaction, url : str):

    def continue_playing():
  
        server = interaction.guild
        voice_channel = server.voice_client

        if len(kolejka_piosenek) > 0:
            for url in kolejka_piosenek:
                source = YTDLSource.from_url(url=url, loop=bot.loop)
                voice_channel.play(discord.FFmpegPCMAudio(source=source), after=lambda e: continue_playing())
                kolejka_piosenek.pop(0)
    
    server = interaction.guild
    voice_channel = server.voice_client

    #piosenka = await YTDLSource.from_url(url=url, loop=bot.loop)
    piosenka = await YTDLSource.create_source()


    if not voice_channel.is_playing():
        voice_channel.play(discord.FFmpegPCMAudio(source=piosenka), after=lambda e: continue_playing())
        await interaction.response.send_message(f'***{piosenka}***',ephemeral=True)
    else:
        voice_channel.stop()
        voice_channel.play(discord.FFmpegPCMAudio(source=piosenka), after=lambda e: continue_playing())
        await interaction.response.send_message(f'***{piosenka}***',ephemeral=True)
        kolejka_piosenek.clear()





@bot.tree.command(name='stop', description='Ko≈Ñczy grƒô')
async def stop(interaction: discord.Interaction):
    
    server = interaction.guild
    voice_channel = server.voice_client

    if voice_channel.is_playing():
        voice_channel.stop()
        await interaction.response.send_message(f'Koniec gry', ephemeral=True)
        kolejka_piosenek.clear()
    else:
        await interaction.response.send_message(f'Przecie≈º ja nic nie gra≈Çem', ephemeral=True)
    

@bot.tree.command(name='resume', description='Wznawia muzykƒô')
async def resume(interaction: discord.Interaction):
    
    server = interaction.guild
    voice_channel = server.voice_client

    if not voice_channel.is_playing():
        voice_channel.resume()
        await interaction.response.send_message(f'Wznawiam grƒô', ephemeral=True)
    else:
        await interaction.response.send_message(f'O co Ci chodzi, przecie≈º ja gram', ephemeral=True)


@bot.tree.command(name='pause', description='Zatrzymuje muzykƒô')
async def pause(interaction: discord.Interaction):
    
    server = interaction.guild
    voice_channel = server.voice_client

    if voice_channel.is_playing():
        voice_channel.pause()
        await interaction.response.send_message(f'Zatrzymujƒô', ephemeral=True)
    else:
        await interaction.response.send_message(f'Przecie≈º ja nic nie gra≈Çem', ephemeral=True)   


@bot.tree.command(name='queue', description='Kolejkuje piosenkƒô')
async def queue(interaction: discord.Interaction, url : str):
    server = interaction.guild
    voice_channel = server.voice_client

    if voice_channel.is_playing():
        kolejka_piosenek.append(url)
        await interaction.response.send_message(f'Dodano do kolejki {url}', ephemeral=True)
        await YTDLSource.from_url(url=url, loop=bot.loop)
    else:
        await interaction.response.send_message(f'Nie mo≈ºesz dodaƒá piosenki do kolejki, najpierw musi co≈õ graƒá', ephemeral=True)



    


#URUCHOMIENIE BOTA
bot.run(TOKEN)
